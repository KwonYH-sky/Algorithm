/*
설거지 다국어
 
시간 제한 메모리 
1 초 128 MB 

문제

베시와 캔무는 카우무스 축제가 끝나고 남은 N(1 <= N <= 10,000) 개의 더러운 설거지 더미를 씻기 위해 
팀을 이루고 있습니다. 베시는 설거지를 하고 캔무우는 설거지를 말립니다.

각 접시에는 1...N 범위의 고유 일련 번호가 있으며, 
처음에 접시는 위에 1번, 아래에 #N 순서로 쌓여 있습니다.

베시는 먼저 들어오는 접시 더미의 맨 위에 있는 
접시 D_i를 하나 꺼내서 씻은 다음 싱크대 반대편에 
쌓는 방식으로 몇 개의 접시를 씻습니다(접시 순서가 뒤바뀜).

설거지가 끝나면 다른 설거지를 하거나 캔무우가 돌아와서 
D_i 설거지를 말리는 동안 베시는 간식을 먹으러 나갑니다. 
캔무우는 베시가 남겨둔 설거지 더미에서 설거지를 하나씩 꺼내서 말린 다음 
'설거지한' 더미에 다시 역순으로 쌓습니다.

그런 다음 캔무우는 다른 설거지 세트를 가져와 말리거나 
베시가 설거지하러 돌아오는 동안 간식을 사러 나갑니다. 모든 식기가 설거지되고 
건조될 때까지 이 작업을 반복합니다.

깨끗하고 마른 식기가 쌓이는 최종 순서(위에서 아래로)는 어떻게 될까요?

예를 들어 베시에게 설거지해야 할 설거지 5개가 쌓여 있다고 가정해 보겠습니다:

1 <-- 맨 위
2
3
4
5 <-- 하단

D_1이 3이므로 베시는 가장 위에 있는 접시 세 개를 하나씩 꺼내서 씻은 다음 캔무우가 말릴 수 있도록 싱크대 반대편에 쌓아둡니다:

       씻지 않은 상태
       | 세척했지만 건조되지 않음
       | | 세척 및 건조
       | | |
TOP    1             
       2          2   
       3      ->  3      ->  3      ->    3   
       4          4          4 2        4 2 
BOTTOM 5 - -      5 1 -      5 1 -      5 1 -
    Initial      Dish 1     Dish 2     Dish 3
    
캔무우는 이 두 가지를 하나씩 말려서 깨끗한 접시 위에 올려놓습니다:

TOP         3                   
          4 2    ->  4 2   ->  4   2
BOTTOM    5 1 -      5 1 3     5 1 3

베시가 마지막 두 접시를 씻습니다:

TOP                              5
          4   2  ->    4 2 ->    4 2
BOTTOM    5 1 3      5 1 3     - 1 3
마지막으로 캔무우는 마지막 세 개의 접시를 말려서 아래 순서대로 쌓습니다:

TOP                                          1
                                  4          4
          5    ->      5  ->      5  ->      5
          4 2        4 2          2          2
BOTTOM  - 1 3      - 1 3      - 1 3      - - 3

따라서 최종 순서는 1, 4, 5, 2, 3입니다.

각 메인 입력 라인에는 1은 베시 세척, 2는 캔뮤 건조를 나타내는 명령어 C_i(1 <= C_i <= 2)와 세척 또는 건조할 식기의 개수 D_i(1 <= D_i <= N)가 모두 포함되어 있습니다.

입력
1줄: 세척 및 건조할 식기의 개수를 나타내는 단일 정수입니다: N
2줄...??: 각 줄에는 처리할 설거지 명령과 설거지 개수가 포함됩니다: C_i 및 D_i
 

출력
라인 1...N: 라인 i에는 위에서부터 i번째로 세척된 접시가 포함됩니다.
 
예제 입력 1 
5
1 3
2 2
1 2
2 3
예제 출력 1 
1
4
5
2
3
*/

#include <iostream>
#include <stack> 


using namespace std;

int main() {
    int N;
    stack<int> stack1;
    stack<int> stack2;
    stack<int> stack3;

    cin >> N;

    for (int i = N; i > 0; i--) {
        stack1.push(i);
    }

    int C, D;
    while (cin >> C >> D) {
        if (C == 1) {
            while (D--) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        } else {
            while (D--) {
                stack3.push(stack2.top());
                stack2.pop();
            }
        }
    }
    
    while (!stack3.empty()) {
        cout << stack3.top() << endl;
        stack3.pop();
    }
    
    return 0;
}