/*
피하자
 
시간 제한	메모리 제한
2 초 (추가 시간 없음)	1024 MB

문제
음이 아닌 정수로 이루어진 길이 N의 배열 A = [A1, A2, · · · , AN]가 있다. 
배열 A에서 인접한 두 수를 교환하는 시행을 원하는 만큼 할 수 있다. 
이 때, 홀수와 짝수가 인접한 경우가 최대 1번 등장하도록 하는 시행의 최소 횟수를 구하여라. 
단, 0 또한 짝수로 간주함에 유의하라.

예를 들어, 아래 그림과 같이 A = [4, 5, 1, 0]인 상황을 살펴보자. 
이 경우, 마지막 두 원소를 교환하는 시행 과 가운데 두 원소를 교환하는 시행을 
차례로 수행하면 A가 [4, 0, 5, 1]이 되어 홀수와 짝수가 인접한 경우가 최대 1번 등장하도록 할 수 있다.



입력
첫 번째 줄에 정수 N이 주어진다.
두 번째 줄에 배열의 원소 A1, A2, · · · , AN이 사이에 공백을 두고 주어진다.

출력
첫 번째 줄에 답을 출력한다.

제한
1 ≤ N ≤ 1 000 000.
0 ≤ Ai ≤ 2 × 109 (1 ≤ i ≤ N).
Ai는 정수이다.
서브태스크
번호	배점	제한
1	10	
N ≤ 3.

2	40	
N ≤ 1 000.

3	50	
추가 제약 조건 없음.

예제 입력 1 
1
1
예제 출력 1 
0
예제 입력 2 
4
4 5 1 0
예제 출력 2 
2
예제 입력 3 
4
1 2 3 1
예제 출력 3 
1
*/

#include <bits/stdc++.h>

using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> a(n);

    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    long long odd = 0, even = 0;
    long long oddCnt = 0, evenCnt = 0;
    
    for(int i = 0; i < n; i++) {
        if (a[i] % 2 == 0) {
            even++; 
            oddCnt += odd; 
        } else {
            odd++;
            evenCnt += even; 
        }
    }

    cout << min(oddCnt, evenCnt) << endl;
    
	return 0;
}