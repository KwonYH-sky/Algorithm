/*
오션뷰
 
시간 제한 메모리 제한
5 초 512 MB
문제

오션뷰는 작은 호수 가장자리에 있는 작은 마을로, 자존감이 높은 사람들이 살고 있습니다. 
이 마을에는 서쪽의 호수에서 동쪽의 언덕을 향해 이어지는 어썸대로라는 단 하나의 도로가 있습니다. 
오션뷰의 모든 집은 어썸 블러바드 한쪽을 따라 호수 가장자리 
1번부터 언덕 아래 #N번까지 번호가 매겨져 있습니다.

오션뷰의 모든 거주자는 호수를 바라볼 수 있기를 원합니다. 
안타깝게도 일부 주택이 높은 번호의 일부 주택의 전망을 가리고 있을 수 있습니다. 
A 하우스가 B 하우스보다 작지만, A 하우스의 높이가 B 하우스와 같거나 더 높을 때마다 
#A 하우스가 #B 하우스의 시야를 가리는 경우가 있습니다.

오션뷰의 최고 통치자는 시야가 가려진다는 불평에 지친 나머지 
자신이 가장 좋아하는 통치 수단인 폭력을 사용하여 문제를 해결하기로 결정했습니다. 
그는 경비병들에게 어썸대로의 일부 집을 부수라고 명령하여 나머지 모든 집이 호수를 볼 수 있도록 합니다. 
물론 너무 많은 집을 파괴하면 반란이 일어날 수 있으므로 가능한 한 적은 수의 집을 파괴하고 싶습니다.

남은 모든 집이 호수의 시야를 가리지 않도록 하기 위해 파괴해야 하는 최소 집 수는 얼마일까요?

입력
입력의 첫 줄에는 테스트 케이스의 개수인 T가 표시됩니다. 각 테스트 케이스는 두 줄로 구성됩니다. 
첫 번째 줄에는 어썸 대로에 있는 집의 수인 단일 정수 N이 포함됩니다. 
다음 줄에는 서쪽에서 동쪽으로 각 집의 높이가 모두 공백으로 구분된 양의 정수로 나열됩니다.

제한값
1 ≤ T ≤ 100.
각 집의 높이는 1에서 1000 사이입니다.
1 ≤ N ≤ 50;
답은 항상 최대 4입니다.
출력
각 테스트 케이스에 대해 “Case #x: y”를 한 줄씩 출력합니다. 
여기서 x는 케이스 번호(1부터 시작)이고 y는 파괴해야 하는 최소 집의 수입니다.

예제 입력 1 
4
4
1 4 3 3
5
3 4 6 7 10
4
4 3 2 1
5
4 5 6 1 7

예제 출력 1 
Case #1: 2
Case #2: 0
Case #3: 3
Case #4: 1
힌트
예제 설명

사례 #1에는 몇 가지 가능한 해결책이 있습니다. 
1번 집은 유지할 수 있지만 나머지 3개의 집 중 두 개를 파괴해야 합니다. 
특히, 3번 집은 4번 집의 시야를 계속 가리기 때문에 가장 높은 집만 파괴하는 것만으로는 충분하지 않습니다.

사례 2는 파괴할 필요가 없습니다. 모든 주민이 이미 호수를 볼 수 있기 때문입니다.

사례 #3은 절망적입니다. 집 중 한 채를 제외한 모든 집을 파괴해야 합니다. 
어느 집을 그대로 두든 상관없습니다.

사례 #4에서는 가장 짧은 집의 거주자만 전망이 없다고 불평하고 있습니다. 
그의 서쪽에 있는 집 3채를 파괴할 수도 있지만, 그 대신 그의 집을 파괴하는 것이 좋습니다. 
그러면 불평하지 않게 될 겁니다.
*/

#include <bits/stdc++.h>

using namespace std;

int main() {
    int T;
    cin >> T;

    for (int i = 0; i < T; i++) {
        int N;
        cin >> N;

        vector<int> v(N);
        for (int j = 0; j < N; j++) {
            cin >> v[j];
        }

        int max = 0;
        int cnt = 0;
        for (int j = 0; j < N; j++) {
            if (v[j] > max) {
                max = v[j];
            } else {
                cnt++;
            }
        }

        cout << "Case #" << i + 1 << ": " << cnt << endl;
    }

    return 0;
}