/*
고고학 발굴
 
시간 제한 메모리 제한
1 초 128 MB

문제
발굴을 하는 고고학자들은 일반적으로 조사하는 지역을 그리드로 나누고 
각 항목이 어느 그리드 셀에서 발견되었는지 기록합니다. 
따라서 주어진 셀에서 몇 개의 아이템이 발견되었는지 쉽게 알 수 있습니다.

입력
이 문제에서는 여러 가지 시나리오가 주어집니다. 
각 시나리오는 그리드의 길이와 너비(0 < X, Y <= 100)를 나타내는 
두 자리 숫자 X와 Y(공백으로 구분)가 포함된 선으로 시작됩니다. 
X와 Y가 모두 0인 시나리오는 입력의 끝을 표시합니다.

시나리오의 두 번째 줄은 고고학자가 찾은 아이템의 수를 나타내는 한 자리 숫자 M(0 < M <= 10000)입니다.
그 다음에는 각각 아이템이 발견된 그리드 셀의 X 및 Y 좌표를 포함하는 M개의 줄이 이어집니다. 
그리드 좌표계는 0, 0에서 시작하며 특정 셀에서 여러 개의 아이템이 발견될 수 있으므로 
셀 좌표가 반복될 수 있다는 점에 유의하세요.

항목 위치의 M줄 뒤에는 발견된 항목의 총 개수가 필요한 셀 참조 목록이 있습니다. 
이 섹션의 첫 번째 줄은 셀의 수를 나타내는 단일 정수인 N입니다(0 < N <= (X * Y)). 
그 다음에는 셀의 X 및 Y 좌표를 각각 포함하는 N개의 줄이 이어집니다.

출력
출력은 각 시나리오에 대해 한 줄로 구성됩니다. 
여기에는 나열된 N개의 셀에서 발견된 항목의 총 개수가 포함됩니다.

예제 입력 1 
10 10
8
4 5
3 4
0 0
1 5
9 9
5 6
3 4
9 9
3
9 9
4 5
6 3
0 0
예제 출력 1 
3
힌트
9,9 셀에는 항목이 2개(입력 목록에 두 번 나타남), 4,5 셀에는 1개, 6,3 셀에는 항목이 없음(입력 목록에 나타나지 않음).
*/

#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    while (true) {
        int x, y;
        cin >> x >> y;
        if (x == 0 && y == 0) break;

        int m;
        cin >> m;

        vector<vector<int>> grid(x, vector<int>(y, 0));
        for (int i = 0; i < m; i++) {
            int a, b;
            cin >> a >> b;
            grid[a][b]++;
        }

        int n;
        cin >> n;

        int ans = 0;
        for (int i = 0; i < n; i++) {
            int a, b;
            cin >> a >> b;
            ans += grid[a][b];
        }

        cout << ans << '\n';
    }  

	return 0;
}
