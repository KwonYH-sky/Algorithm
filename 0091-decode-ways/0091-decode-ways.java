/*
91. 디코딩 방법

A-Z의 문자가 포함된 메시지는 다음 매핑을 사용하여 숫자로 인코딩할 수 있습니다:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
인코딩된 메시지를 디코딩하려면 모든 숫자를 그룹화한 다음 위 매핑의 역방향을 사용하여 다시 문자로 매핑해야 합니다(여러 가지 방법이 있을 수 있음). 예를 들어, "11106"은 다음과 같이 매핑할 수 있습니다:

그룹화(1 1 10 6)와 함께 "AAJF"
그룹화(11 10 6)를 사용한 "KJF"
그룹화(1 11 06)는 "6"이 "06"과 다르기 때문에 "06"을 'F'에 매핑할 수 없으므로 유효하지 않습니다.

숫자만 포함된 문자열 s가 주어졌을 때, 이를 디코딩하는 방법의 수를 반환합니다.

테스트 케이스는 대답이 32비트 정수에 맞도록 생성됩니다.

예제 1:

입력: s = "12"
Output: 2
설명: "12"는 "AB"(1 2) 또는 "L"(12)로 디코딩될 수 있습니다.

예제 2:
입력: s = "226"
출력 3
설명: "226"은 "BZ"(2 26), "VF"(22 6) 또는 "BBF"(2 2 6)로 디코딩할 수 있습니다.

예제 3:
입력: s = "06"
Output: 0
설명: "06"은 선행 0 때문에 "F"에 매핑할 수 없습니다("6"은 "06"과 다름).
 
제약 조건:

1 <= s.length <= 100
s는 숫자만 포함하며 선행 0을 포함할 수 있습니다.
*/

class Solution {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0) return 0;

        int n = s.length();
        int[] dp = new int[n + 1];

        dp[0] = 1;
        dp[1] = s.charAt(0) != '0' ? 1 : 0;

        for (int i = 2; i <= n; i++) {
            int first = Integer.parseInt(s.substring(i - 1, i));
            int second = Integer.parseInt(s.substring(i - 2, i));

            if (first >= 1 && first <= 9) dp[i] += dp[i-1];
            if (second >= 10 && second <= 26) dp[i] += dp[i-2];
        }

        return dp[n];
    }
}